{
  "name": "Schemify.Kt",
  "tagline": "Schemification and serialization API for Kotlin",
  "body": "# APIs:\r\n* [**Schemification API**](#schemification-api): Creating a scheme of a class.\r\n* [**Serialization API**](#serialization-api): Transforming an instance of schemified class from/to other format.\r\n\r\n***\r\n\r\n## Schemification API\r\nStructure of a class can be represented as a **Scheme** by mapping class properties (fields) to scheme **Props**.  \r\n> \r\n![smf_fieldprop](https://cloud.githubusercontent.com/assets/5307477/17297455/72287c36-580e-11e6-8efd-fc9f46e9a3c8.png)\r\n\r\nSince the scheme of the class is [**defined**](#defining-scheme) it can be used for:\r\n* [**serialization**](#scheme-serialization):\r\n    * instance of that class can be read from other format (e.g. json string)\r\n    * instance of that class can be written to other format (e.g. xml string)\r\n* [**props manipulation**](#prop-manipulation): \r\n    * instance of that class can be assigned with values via props\r\n    * props can be used for class structure utilization\r\n    * prop's attributes such as name, index, custom extras can be used in DSLs, building structured queries, etc. \r\n* [**extended methods**](#extended-methods) calls on instance of that class such as equal, copy, toString, hashCode\r\n\r\n\r\n> _Terms:  \r\n**Scheme** is a special type that represents a class structure as set of Props  \r\n**Schemified class** is the class that has the scheme   \r\n**Prop** is a special type that represents schemified class property (field)  \r\n**Schemified instance** is an instance of the schemified class_  \r\n\r\n\r\n### Defining Scheme\r\n- Scheme of class `T` can be defined by extending class [`SCHEMAof<T>`](https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/types.kt#L808). And for each exposing field of class `T` the corresponding prop (`val` of type [`Prop<P>`](https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/prop.kt#L9)) in the scheme should be created.\r\n> \r\n![smf_define_scheme](https://cloud.githubusercontent.com/assets/5307477/17297564/e13852cc-580e-11e6-8571-d25ca25ad6f8.png)\r\n\r\n- A prop's name and its generic type argument `P` should match the field's name and type.  \r\nBoth nullable and non-nullable field types correspond to non-nullable prop type argument.\r\n> \r\n![smf_define_props](https://cloud.githubusercontent.com/assets/5307477/17297604/1a58ec42-580f-11e6-9e06-bbe10ae1096d.png)\r\n\r\n- Props can be constructed via the methods in the `Scheme` class that start from  `PROP_...`.  \r\nProps support those field types for which a corresponding [`PropType<P>`](https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/types.kt#L15) is defined.  \r\nThe following field types are supported initially:  \r\n> \r\n| Field type | Constructor | Description |\r\n| --- | --- | --- |\r\n|`Unit`|`PROP_STUB()`|for _stub_ props|\r\n|`String`|`PROP_String()`|String type|\r\n|Primitive types|`PROP_Long()`, ...|All primitive types: `Long`, `Byte`, etc.|\r\n|Primitive arrays|`PROP_Longs()`, ...|All primitive arrays: `LongArray`, `ByteArray`, etc.|\r\n|`Array<Any?>`|`PROP_Array()`|Raw array type|\r\n|`Collection<Any?>`|`PROP_Collection()`|Raw collection type|\r\n|`MutableMap<String, Any?>`|`PROP_Map()`|Raw map type|\r\n|Schemified class|`PROP_of(scheme)`|Any class that has scheme|\r\n|`T: Any`|`PROP_AutoSchemaOf<T>`|Any class `T`. Auto-generates scheme for `T`|\r\n|`Long` wrapper|`PROP_of(value_type)`|Any class `T` that has a `LONGof<T>` defined|\r\n|`String` wrapper|`PROP_of(value_type)`|Any class `T` that has a `STRINGof<T>` defined|\r\n|`ByteArray` wrapper|`PROP_of(value_type)`|Any class `T` that has a `BYTESof<T>` defined|\r\n|`Array<E>`|`PROP_ArrayOf(type_of_E)`|Array of type `E` that has a `PropType<E>` defined|\r\n|`List<E>`|`PROP_ListOf(type_of_E)`|List of type `E` that has a `PropType<E>` defined|\r\n|`MutableList<E>`|`PROP_MutableListOf(type_of_E)`|Mutable list of type `E` that has a `PropType<E>` defined|\r\n|`Set<E>`|`PROP_SetOf(type_of_E)`|Set of type `E` that has a `PropType<E>` defined|\r\n|`MutableSet<E>`|`PROP_MutableSetOf(type_of_E)`|Mutable set of type `E` that has a `PropType<E>` defined|\r\n|`T: Any`|`PROP_of(type_of_T)`|Any class that has a `PropType<T>` defined|  \r\n|`T: Collection<E>`|`PROP_of(coll_type)`|Any collection `T` that has a `COLLECTIONof<T, E>` defined|  \r\nThe following `PropType`s can be extended to support custom field types: `SCHEMAof<T>`, `LONGof<T>`, `STRINGof<T>`, `BYTESof<T>`, `COLLECTIONof<T, E>`.\r\n\r\n- Prop should be assigned via delegation and not with `=` sign because prop has lazy initialization.\r\n> \r\n![smf_prop_assign_by](https://cloud.githubusercontent.com/assets/5307477/17269119/e8208572-5648-11e6-9683-48053a1946a3.png)\r\n\r\n- Prop has index indicating its declaration position within the schema.  \r\nPosition of prop in the scheme may NOT match the position of corresponding field in schemified class.\r\n> \r\n![smf_prop_indexes](https://cloud.githubusercontent.com/assets/5307477/17269101/59a43028-5648-11e6-9314-92554abd7ccd.png)\r\n\r\n- By default variable field **`var`** can be modified and final field **`val`** can not be modified via corresponding prop. But default behavior can be altered by setting constructing method argument `writeProtected`.\r\n> \r\n![smf_write_protect](https://cloud.githubusercontent.com/assets/5307477/17269164/7444781e-564a-11e6-9170-2164faabb951.png)\r\n\r\n- Field with access modifier (private etc) is still accessible via corresponding prop.\r\n> \r\n![smf_prop_access](https://cloud.githubusercontent.com/assets/5307477/17269200/047134d6-564b-11e6-8e18-86708d401c18.png)\r\n\r\n- By default prop is configured to use Kotlin reflection instead of Java one to access related field. It’s slower (about 2 times) but it’s required in order to invoke custom field accessors. But if field doesn’t have custom getter or setter than it may be reasonable to configure prop to use Java reflection by setting method argument `hasNoAccessors` to true.\r\n> \r\n![smf_prop_accessors](https://cloud.githubusercontent.com/assets/5307477/17269236/cedcd720-564b-11e6-83cc-76be5bc857fd.png)\r\n\r\n- If schemified class has main non-empty constructor it should only have class fields (`val` or `var`) as arguments and only those fields that have corresponding props in the scheme. But API can not detect whether constructor argument is declared with `val`/`var` or without.  \r\nOrder of fields in constructor doesn’t matter.  \r\nConstructor with access modifier is still accessible by the scheme.  \r\n> \r\n![smf_constructor](https://cloud.githubusercontent.com/assets/5307477/17269308/7da7c340-564d-11e6-8a19-61addebfc88e.png)\r\n\r\n\r\n### Scheme serialization\r\nAn instance of schemified class can be transformed to / from another format via Serialization API by means of its scheme.  \r\nScheme `read` method can be called to produce new schemified instance from formatted object.   \r\nScheme `write` method can be called to produce formatted object from schemified instance.  \r\n\r\nThe formatted object can be represented in:\r\n* general form (as sequence of named entries)\r\n* compact form (as sequence of non-named entries i.e. an array of values).  \r\n\r\nDefault representation is controlled by scheme `compact` property. Optional `compact` argument of write method can overwrite that property.  \r\n> \r\n```scala\r\nval sabretooth = XMan()\r\nval generalJson = XSchema.write(sabretooth, JsonFactory) // {“id”:3,“firstname”:”sabretooth”,,,,}\r\nval compactJson = XSchema.write(sabretooth, JsonFactory, compact=true) // [3,”sabretooth”,,,,]\r\nval sabreCopy = XSchema.read(generalJson, JsonFactory)\r\n```\r\n\r\n### Compact form\r\nBenefit of the compact form is its concise representation.   \r\n> _Example based on Json implementation:_  \r\n![smf_compact_vs_general](https://cloud.githubusercontent.com/assets/5307477/17270002/7669aa86-5660-11e6-928b-2e669bb95452.png)\r\n\r\nOne more advantage of compact form is zero scheme evolution.  \r\nThat is no scheme migration efforts required to read a schemified instance from an object formatted by an older version of the scheme and vice versa.  \r\n\r\nSince the Compact form relies on props indexes instead of names it imposes the following restriction on scheme definition and evolution: props indexes stays intact. I.e. as long as prop index corresponds to its declaration position within the scheme, props neither should be removed nor their declaration positions should be changed.  \r\nThe \r\n\r\n \r\nI.e. none of the changes to the schemified class (field addition / change / removal) affects a transformation of schemified instance produced by an older schema into a newer one and vice versa if props indexes stays intact.   \r\nAs long as prop index corresponds to its declaration position within the schema, props neither should be removed nor their declaration positions should be changed. \r\n\r\n- Changing field name or type:  \r\nIn case of renaming a field its corresponding prop should also be renamed. In case of changing type of a field its corresponding prop’s type should also be changed accordingly. As the representation does not include prop names, changing field name has no effect to transformation. Since API provides basic types casting (// TODO specify which ones), changing field type is compensated by value auto casting in most cases.  \r\n> \r\n![smf_evo_change](https://cloud.githubusercontent.com/assets/5307477/17270017/f693e44c-5660-11e6-8f47-c0eb769e2ba8.png)\r\n\r\n- Field addition:  \r\nIn case of addition a new field the corresponding prop should be just declared after all other props. Adding a field just appends a value to the top a sequence of values. Reading an object written by scheme with older version by scheme with newer version will just assign a default value to the extra field. Reading an object written by newer version of schema with older version will ignore absent value.  \r\n> \r\n![smf_evo_add](https://cloud.githubusercontent.com/assets/5307477/17270018/f8a1e6e4-5660-11e6-9068-f97b178efcd0.png)\r\n\r\n- Field removal:   \r\nIn case of removing a field its corresponding prop should be left and just change its type to Prop<Unit> which is returned by calling PROP_STUB() construction method. Removing a field creates a “hole” in the schema that is just a change of a type of corresponding prop to Prop<Unit>.   \r\n> \r\n![smf_evo_remove](https://cloud.githubusercontent.com/assets/5307477/17270020/fa73fd4a-5660-11e6-8dae-5b07f2e404f5.png)\r\n\r\n\r\n### Prop manipulation\r\n- If a prop doesn’t have the related field in schemified class accessing it will just return null value.  \r\nTo explicitly declare a prop that doesn’t have the related field it should be created via PROP_STUB() method which returns prop of type Prop<Unit>. It’s useful when using compact representation and zero evolution scheme (see next).\r\n\r\n\r\n***\r\n\r\n## Serialization API\r\n**Container** of **entries** represented in one **format** can be transformed to another format.  \r\n> \r\n![ser_examples](https://cloud.githubusercontent.com/assets/5307477/17268380/84b1451a-5631-11e6-95a9-aceacb1fe1ca.png)\r\n\r\n**Container** of type OUT is created by calling _Produce(reader: Reader<IN>, writer: Writer<OUT>)_.\r\nReader<IN> extracts entries from a container of type IN. Those are passed to Writer<OUT> which writes them to the container of type OUT.  \r\nThere are default implementations of Reader and Writer for Json, Xml and Scheme format. For convenience there are also factory singletons for creating their instances.  \r\n_Examples:_\r\n```scala\r\nval orderJson = Produce(SchemeReader(order1, OrderScheme), JsonFactory())\r\nval order2 = Produce(JsonFactory(orderJson), SchemeWriter(OrderScheme))\r\n```\r\n\r\nEntry is a holder of some data. Entry can be named (holding name-value pair) or non-named (holding just value).  \r\nContainer representation should conform the structure:\r\n\r\n![ser_flow](https://cloud.githubusercontent.com/assets/5307477/17268685/76de9650-563a-11e6-91e4-6aeb7ac79034.png)\r\n\r\nSpecific symbols for concrete records, their delimiters and way of encoding named-entry are up to Reader and Writer implementation.  \r\nAtomic value is a data of following base types: String, ByteArray and all the java primitive types.\r\n\r\nTo implement custom Reader [`class Reader<T>`](https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/production.kt#L148) should be extended. And the following methods should be implemented:\r\n```scala\r\ndef readRootEntry(entryBuilder: EntryBuilder): Entry\r\ndef readNextEntry(entryBuilder: EntryBuilder, contextIsSequence: Boolean): Entry\r\n```\r\nTo implement custom Writer [`class Writer<T>`](https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/production.kt#L162) should be extended. And the following methods should be implemented:\r\n```scala\r\ndef result(): T?\r\ndef writeRootEntry(isSequence: Boolean, content: EnclosingEntries): Unit\r\ndef writeObjectEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeSequenceEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeAtomicEntry(value: [all atomic types], name: String?, index: Int): Unit\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}