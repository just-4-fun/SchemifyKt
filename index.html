<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Schemify.Kt by just-4-fun</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Schemify.Kt</h1>
      <h2 class="project-tagline">Schemification and serialization API for Kotlin</h2>
      <a href="https://github.com/just-4-fun/SchemifyKt" class="btn">View on GitHub</a>
      <a href="https://github.com/just-4-fun/SchemifyKt/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/just-4-fun/SchemifyKt/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="apis" class="anchor" href="#apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>APIs:</h1>

<ul>
<li>
<a href="#schemification-api"><strong>Schemification API</strong></a>: Creating a scheme of a class.</li>
<li>
<a href="#serialization-api"><strong>Serialization API</strong></a>: Transforming an instance of schemified class from/to other format.</li>
</ul>

<hr>

<h2>
<a id="schemification-api" class="anchor" href="#schemification-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schemification API</h2>

<p>Structure of a class can be represented as a <strong>Scheme</strong> by mapping class properties (fields) to scheme <strong>Props</strong>.  </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17297455/72287c36-580e-11e6-8efd-fc9f46e9a3c8.png" alt="smf_fieldprop"></p>
</blockquote>

<p>Since the scheme of the class is <a href="#defining-scheme"><strong>defined</strong></a> it can be used for:</p>

<ul>
<li>
<a href="#scheme-serialization"><strong>serialization</strong></a>:

<ul>
<li>instance of that class can be read from other format (e.g. json string)</li>
<li>instance of that class can be written to other format (e.g. xml string)</li>
</ul>
</li>
<li>
<a href="#prop-manipulation"><strong>props manipulation</strong></a>: 

<ul>
<li>instance of that class can be assigned with values via props</li>
<li>props can be used for class structure utilization</li>
<li>prop's attributes such as name, index, custom extras can be used in DSLs, building structured queries, etc. </li>
</ul>
</li>
<li>
<a href="#extended-methods"><strong>extended methods</strong></a> calls on instance of that class such as equal, copy, toString, hashCode</li>
</ul>

<blockquote>
<p><em>Terms:<br>
<strong>Scheme</strong> is a special type that represents a class structure as set of Props<br>
<strong>Schemified class</strong> is the class that has the scheme<br>
<strong>Prop</strong> is a special type that represents schemified class property (field)<br>
<strong>Schemified instance</strong> is an instance of the schemified class</em>  </p>
</blockquote>

<h3>
<a id="defining-scheme" class="anchor" href="#defining-scheme" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Defining Scheme</h3>

<ul>
<li>
<p>Scheme of class <code>T</code> can be defined by extending class <a href="https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/types.kt#L808"><code>SCHEMAof&lt;T&gt;</code></a>. And for each exposing field of class <code>T</code> the corresponding prop (<code>val</code> of type <a href="https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/prop.kt#L9"><code>Prop&lt;P&gt;</code></a>) in the scheme should be created.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17297564/e13852cc-580e-11e6-8571-d25ca25ad6f8.png" alt="smf_define_scheme"></p>
</blockquote>
</li>
<li>
<p>A prop's name and its generic type argument <code>P</code> should match the field's name and type.<br>
Both nullable and non-nullable field types correspond to non-nullable prop type argument.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17297604/1a58ec42-580f-11e6-9e06-bbe10ae1096d.png" alt="smf_define_props">  </p>
</blockquote>
</li>
<li><p>If a prop doesn’t have the related field in schemified class accessing it will just return null value.  </p></li>
<li>
<p>Props can be constructed via the methods in the <code>Scheme</code> class that start from  <code>PROP_...</code>.<br>
Props support those field types for which a corresponding <a href="https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/types.kt#L15"><code>PropType&lt;P&gt;</code></a> is defined.<br>
The following field types are supported initially:  </p>

<blockquote>
<table>
<thead>
<tr>
<th>Field type</th>
<th>Constructor</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Unit</code></td>
<td><code>PROP_STUB()</code></td>
<td>for <em>stub</em> props</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>PROP_String()</code></td>
<td>String type</td>
</tr>
<tr>
<td>Primitive types</td>
<td>
<code>PROP_Long()</code>, ...</td>
<td>All primitive types: <code>Long</code>, <code>Byte</code>, etc.</td>
</tr>
<tr>
<td>Primitive arrays</td>
<td>
<code>PROP_Longs()</code>, ...</td>
<td>All primitive arrays: <code>LongArray</code>, <code>ByteArray</code>, etc.</td>
</tr>
<tr>
<td><code>Array&lt;Any?&gt;</code></td>
<td><code>PROP_Array()</code></td>
<td>Raw array type</td>
</tr>
<tr>
<td><code>Collection&lt;Any?&gt;</code></td>
<td><code>PROP_Collection()</code></td>
<td>Raw collection type</td>
</tr>
<tr>
<td><code>MutableMap&lt;String, Any?&gt;</code></td>
<td><code>PROP_Map()</code></td>
<td>Raw map type</td>
</tr>
<tr>
<td>Schemified class</td>
<td><code>PROP_of(scheme)</code></td>
<td>Any class that has scheme</td>
</tr>
<tr>
<td><code>T: Any</code></td>
<td><code>PROP_AutoSchemaOf&lt;T&gt;</code></td>
<td>Any class <code>T</code>. Auto-generates scheme for <code>T</code>
</td>
</tr>
<tr>
<td>
<code>Long</code> wrapper</td>
<td><code>PROP_of(value_type)</code></td>
<td>Any class <code>T</code> that has a <code>LONGof&lt;T&gt;</code> defined</td>
</tr>
<tr>
<td>
<code>String</code> wrapper</td>
<td><code>PROP_of(value_type)</code></td>
<td>Any class <code>T</code> that has a <code>STRINGof&lt;T&gt;</code> defined</td>
</tr>
<tr>
<td>
<code>ByteArray</code> wrapper</td>
<td><code>PROP_of(value_type)</code></td>
<td>Any class <code>T</code> that has a <code>BYTESof&lt;T&gt;</code> defined</td>
</tr>
<tr>
<td><code>Array&lt;E&gt;</code></td>
<td><code>PROP_ArrayOf(type_of_E)</code></td>
<td>Array of type <code>E</code> that has a <code>PropType&lt;E&gt;</code> defined</td>
</tr>
<tr>
<td><code>List&lt;E&gt;</code></td>
<td><code>PROP_ListOf(type_of_E)</code></td>
<td>List of type <code>E</code> that has a <code>PropType&lt;E&gt;</code> defined</td>
</tr>
<tr>
<td><code>MutableList&lt;E&gt;</code></td>
<td><code>PROP_MutableListOf(type_of_E)</code></td>
<td>Mutable list of type <code>E</code> that has a <code>PropType&lt;E&gt;</code> defined</td>
</tr>
<tr>
<td><code>Set&lt;E&gt;</code></td>
<td><code>PROP_SetOf(type_of_E)</code></td>
<td>Set of type <code>E</code> that has a <code>PropType&lt;E&gt;</code> defined</td>
</tr>
<tr>
<td><code>MutableSet&lt;E&gt;</code></td>
<td><code>PROP_MutableSetOf(type_of_E)</code></td>
<td>Mutable set of type <code>E</code> that has a <code>PropType&lt;E&gt;</code> defined</td>
</tr>
<tr>
<td><code>T: Any</code></td>
<td><code>PROP_of(type_of_T)</code></td>
<td>Any class that has a <code>PropType&lt;T&gt;</code> defined</td>
</tr>
<tr>
<td><code>T: Collection&lt;E&gt;</code></td>
<td><code>PROP_of(coll_type)</code></td>
<td>Any collection <code>T</code> that has a <code>COLLECTIONof&lt;T, E&gt;</code> defined</td>
</tr>
</tbody>
</table>

<p>The following <code>PropType</code>s can be extended to support custom field types: <code>SCHEMAof&lt;T&gt;</code>, <code>LONGof&lt;T&gt;</code>, <code>STRINGof&lt;T&gt;</code>, <code>BYTESof&lt;T&gt;</code>, <code>COLLECTIONof&lt;T, E&gt;</code>.</p>
</blockquote>
</li>
<li>
<p>Prop should be assigned via delegation and not with <code>=</code> sign because prop has lazy initialization.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269119/e8208572-5648-11e6-9683-48053a1946a3.png" alt="smf_prop_assign_by"></p>
</blockquote>
</li>
<li>
<p>Prop has index indicating its declaration position within the schema.<br>
Position of prop in the scheme may NOT match the position of corresponding field in schemified class.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269101/59a43028-5648-11e6-9314-92554abd7ccd.png" alt="smf_prop_indexes"></p>
</blockquote>
</li>
<li>
<p>By default variable field <strong><code>var</code></strong> can be modified and final field <strong><code>val</code></strong> can not be modified via corresponding prop. But default behavior can be altered by setting constructing method argument <code>writeProtected</code>.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269164/7444781e-564a-11e6-9170-2164faabb951.png" alt="smf_write_protect"></p>
</blockquote>
</li>
<li>
<p>Field with access modifier (private etc) is still accessible via corresponding prop.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269200/047134d6-564b-11e6-8e18-86708d401c18.png" alt="smf_prop_access"></p>
</blockquote>
</li>
<li>
<p>By default prop is configured to use Kotlin reflection instead of Java one to access related field. It’s slower (about 2 times) but it’s required in order to invoke custom field accessors. But if field doesn’t have custom getter or setter than it may be reasonable to configure prop to use Java reflection by setting method argument <code>hasNoAccessors</code> to true.</p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269236/cedcd720-564b-11e6-83cc-76be5bc857fd.png" alt="smf_prop_accessors"></p>
</blockquote>
</li>
<li>
<p>If schemified class has main non-empty constructor it should only have class fields (<code>val</code> or <code>var</code>) as arguments and only those fields that have corresponding props in the scheme. But API can not detect whether constructor argument is declared with <code>val</code>/<code>var</code> or without.<br>
Order of fields in constructor doesn’t matter.<br>
Constructor with access modifier is still accessible by the scheme.  </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17269308/7da7c340-564d-11e6-8a19-61addebfc88e.png" alt="smf_constructor"></p>
</blockquote>
</li>
</ul>

<h3>
<a id="scheme-serialization" class="anchor" href="#scheme-serialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scheme serialization</h3>

<p>An instance of schemified class can be transformed to / from another format via Serialization API by means of its scheme.<br>
Scheme <code>read</code> method can be called to produce new schemified instance from formatted object.<br>
Scheme <code>write</code> method can be called to produce formatted object from schemified instance.  </p>

<p>The formatted object can be represented in:</p>

<ul>
<li>general form (as sequence of named entries)</li>
<li>
<strong>compact form</strong> (as sequence of non-named entries i.e. an array of values).<br>
</li>
</ul>

<blockquote>
<p><em>Example based on Json implementation:</em><br>
<img src="https://cloud.githubusercontent.com/assets/5307477/17270002/7669aa86-5660-11e6-928b-2e669bb95452.png" alt="smf_compact_vs_general">  </p>
</blockquote>

<p>Default representation is controlled by scheme <code>compact</code> property. Optional <code>compact</code> argument of write method can overwrite that property.  </p>

<blockquote>
<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">sabretooth</span> <span class="pl-k">=</span> <span class="pl-en">XMan</span>()
<span class="pl-k">val</span> <span class="pl-en">generalJson</span> <span class="pl-k">=</span> <span class="pl-en">XSchema</span>.write(sabretooth, <span class="pl-en">JsonFactory</span>) <span class="pl-c">// {“id”:3,“firstname”:”sabretooth”,,,,}</span>
<span class="pl-k">val</span> <span class="pl-en">compactJson</span> <span class="pl-k">=</span> <span class="pl-en">XSchema</span>.write(sabretooth, <span class="pl-en">JsonFactory</span>, compact<span class="pl-k">=</span><span class="pl-c1">true</span>) <span class="pl-c">// [3,”sabretooth”,,,,]</span>
<span class="pl-k">val</span> <span class="pl-en">sabreCopy</span> <span class="pl-k">=</span> <span class="pl-en">XSchema</span>.read(generalJson, <span class="pl-en">JsonFactory</span>)</pre></div>
</blockquote>

<h3>
<a id="compact-form" class="anchor" href="#compact-form" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Compact form</h3>

<p>Benefit of the compact form is in its concise representation.<br>
One more advantage of compact form is zero scheme evolution. That is no scheme migration efforts required to read a schemified instance from an object formatted by an older version of the scheme and vice versa.  </p>

<p>Since the compact form relies on props indexes (instead of names) they should stays intact. I.e. as long as prop index corresponds to its declaration position within the scheme, props neither should be removed nor their declaration positions should be changed.<br>
Changes to class such as field addition / change / removal that usually (in general form) involve its scheme evolution management, in compact form are performed in the following:  </p>

<ul>
<li>
<p>Changing field name or type:<br>
In case of renaming a field its corresponding prop should also be renamed. In case of changing type of a field its corresponding prop’s type should also be changed accordingly. Changing field name has no effect on transformation as the compact representation does not include props names. Changing field type in most cases is compensated by provided value auto casting.  </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17270017/f693e44c-5660-11e6-8f47-c0eb769e2ba8.png" alt="smf_evo_change"></p>
</blockquote>
</li>
<li>
<p>Field addition:<br>
In case of addition a new field the corresponding prop should just be declared after all other props. Reading an older formatted object by the scheme with newer version will just assign a default value to the extra field. Reading a newer formatted object by the scheme with older version will ignore absent value.  </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17270018/f8a1e6e4-5660-11e6-9068-f97b178efcd0.png" alt="smf_evo_add"></p>
</blockquote>
</li>
<li>
<p>Field removal:<br>
In case of removing a field its corresponding prop should be left and just change its type to <code>Prop&lt;Unit&gt;</code>. To construct such stub prop the scheme <code>PROP_STUB()</code> method can be used. Reading an older formatted object by the scheme with newer version will ignore an extra value. Reading a newer formatted object by the scheme with older version will assign a default value to the extra field.      </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17270020/fa73fd4a-5660-11e6-8dae-5b07f2e404f5.png" alt="smf_evo_remove"></p>
</blockquote>
</li>
</ul>

<h3>
<a id="prop-manipulation" class="anchor" href="#prop-manipulation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prop manipulation</h3>

<ul>
<li>Scheme allows to access to class structure. 

<ul>
<li>Props are available as a list via <code>props: List&lt;Prop&lt;Any&gt;&gt;</code>
</li>
<li>Prop can be queried by name via <code>propMap: Map&lt;String, Prop&lt;Any&gt;&gt;</code>
</li>
<li>Number of props is available via <code>propSize</code><br>
</li>
</ul>
</li>
<li>Props can be used in building structured queries:<br>
&gt; </li>
</ul>

<pre><code>data class Point(val x: Int, val y: Int){
    companion object : PropType.SCHEMAof&lt;Point&gt;(Point::class) {
        val x by PROP_Int()
        val y by PROP_Int()
    }
}

val query = "SELECT " + Point.x.name + "," + Point.y.name + " FROM Point" // SELECT x,y FROM Point
</code></pre>

<hr>

<h2>
<a id="serialization-api" class="anchor" href="#serialization-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Serialization API</h2>

<p><strong>Container</strong> of <strong>entries</strong> represented in one <strong>format</strong> can be transformed to another format.  </p>

<blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/5307477/17268380/84b1451a-5631-11e6-95a9-aceacb1fe1ca.png" alt="ser_examples"></p>
</blockquote>

<p><strong>Container</strong> of type OUT is created by calling <em>Produce(reader: Reader, writer: Writer)</em>.
Reader extracts entries from a container of type IN. Those are passed to Writer which writes them to the container of type OUT.<br>
There are default implementations of Reader and Writer for Json, Xml and Scheme format. For convenience there are also factory singletons for creating their instances.<br>
<em>Examples:</em></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">orderJson</span> <span class="pl-k">=</span> <span class="pl-en">Produce</span>(<span class="pl-en">SchemeReader</span>(order1, <span class="pl-en">OrderScheme</span>), <span class="pl-en">JsonFactory</span>())
<span class="pl-k">val</span> <span class="pl-en">order2</span> <span class="pl-k">=</span> <span class="pl-en">Produce</span>(<span class="pl-en">JsonFactory</span>(orderJson), <span class="pl-en">SchemeWriter</span>(<span class="pl-en">OrderScheme</span>))</pre></div>

<p>Entry is a holder of some data. Entry can be named (holding name-value pair) or non-named (holding just value).<br>
Container representation should conform the structure:</p>

<p><img src="https://cloud.githubusercontent.com/assets/5307477/17268685/76de9650-563a-11e6-91e4-6aeb7ac79034.png" alt="ser_flow"></p>

<p>Specific symbols for concrete records, their delimiters and way of encoding named-entry are up to Reader and Writer implementation.<br>
Atomic value is a data of following base types: String, ByteArray and all the java primitive types.</p>

<p>To implement custom Reader <a href="https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/production.kt#L148"><code>class Reader&lt;T&gt;</code></a> should be extended. And the following methods should be implemented:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">def</span> <span class="pl-en">readRootEntry</span>(<span class="pl-v">entryBuilder</span>: <span class="pl-en">EntryBuilder</span>)<span class="pl-k">:</span> <span class="pl-en">Entry</span>
<span class="pl-k">def</span> <span class="pl-en">readNextEntry</span>(<span class="pl-v">entryBuilder</span>: <span class="pl-en">EntryBuilder</span>, <span class="pl-v">contextIsSequence</span>: <span class="pl-k">Boolean</span>)<span class="pl-k">:</span> <span class="pl-en">Entry</span></pre></div>

<p>To implement custom Writer <a href="https://github.com/just-4-fun/SchemifyKt/blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/production.kt#L162"><code>class Writer&lt;T&gt;</code></a> should be extended. And the following methods should be implemented:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">def</span> <span class="pl-en">result</span>()<span class="pl-k">:</span> <span class="pl-en">T</span><span class="pl-k">?</span>
<span class="pl-k">def</span> <span class="pl-en">writeRootEntry</span>(<span class="pl-v">isSequence</span>: <span class="pl-k">Boolean</span>, <span class="pl-v">content</span>: <span class="pl-en">EnclosingEntries</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>
<span class="pl-k">def</span> <span class="pl-en">writeObjectEntry</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span><span class="pl-k">?</span>, <span class="pl-v">index</span>: <span class="pl-k">Int</span>, <span class="pl-v">content</span>: <span class="pl-en">EnclosingEntries</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>
<span class="pl-k">def</span> <span class="pl-en">writeSequenceEntry</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span><span class="pl-k">?</span>, <span class="pl-v">index</span>: <span class="pl-k">Int</span>, <span class="pl-v">content</span>: <span class="pl-en">EnclosingEntries</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>
<span class="pl-k">def</span> <span class="pl-en">writeAtomicEntry</span>(<span class="pl-v">value</span>: [all atomic types], <span class="pl-v">name</span>: <span class="pl-k">String</span><span class="pl-k">?</span>, <span class="pl-v">index</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span></pre></div>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/just-4-fun/SchemifyKt">Schemify.Kt</a> is maintained by <a href="https://github.com/just-4-fun">just-4-fun</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
