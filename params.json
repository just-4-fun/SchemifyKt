{
  "name": "Schemify.Kt",
  "tagline": "Schemification and serialization API for Kotlin",
  "body": "# APIs:\r\n* [**Schemification API**](#schemification-api): Creating a scheme of a class.\r\n* [**Serialization API**](#serialization-api): Transforming an instance of schemified class from/to other format.\r\n\r\n***\r\n\r\n## Schemification API\r\nStructure of a class can be represented as a **Scheme** by mapping class fields to scheme **Props**.  \r\n_In this sense scheme is a special class that represent other class structure as set of Props._  \r\n_Example:_\r\n\r\n\r\n***\r\n\r\n## Serialization API\r\n**Container** of **entries** represented in one **format** can be transformed to another format.  \r\n_Examples:_\r\n![ser_examples](https://cloud.githubusercontent.com/assets/5307477/17268380/84b1451a-5631-11e6-95a9-aceacb1fe1ca.png)\r\n**Container** of type OUT is created by calling _Produce(reader: Reader<IN>, writer: Writer<OUT>)_.\r\nReader<IN> extracts entries from a container of type IN. Those are passed to Writer<OUT> which writes them to the container of type OUT.  \r\nThere are default implementations of Reader and Writer for Json, Xml and Scheme format. For convenience there are also factory singletons for creating their instances.  \r\n_Examples:_\r\n```scala\r\nval orderJson = Produce(SchemeReader(order1, OrderScheme), JsonFactory())\r\nval order2 = Produce(JsonFactory(orderJson), SchemeWriter(OrderScheme))\r\n```\r\n\r\nEntry is a holder of some data. Entry can be named (holding name-value pair) or non-named (holding just value).  \r\nContainer representation should conform the structure:\r\n\r\n![ser_flow](https://cloud.githubusercontent.com/assets/5307477/17268685/76de9650-563a-11e6-91e4-6aeb7ac79034.png)\r\n\r\nSpecific symbols for concrete records, their delimiters and way of encoding named-entry are up to Reader and Writer implementation.  \r\nAtomic value is a data of following base types: String, ByteArray and all the java primitive types.\r\n\r\nTo implement custom Reader class Reader<T : Any> should be extended. And the following methods should be implemented:\r\n```scala\r\ndef readRootEntry(entryBuilder: EntryBuilder): Entry\r\ndef readNextEntry(entryBuilder: EntryBuilder, contextIsSequence: Boolean): Entry\r\n```\r\nTo implement custom Writer class Writer<T : Any> should be extended. And the following methods should be implemented:\r\n```scala\r\ndef result(): T?\r\ndef writeRootEntry(isSequence: Boolean, content: EnclosingEntries): Unit\r\ndef writeObjectEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeSequenceEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeAtomicEntry(value: [all atomic types], name: String?, index: Int): Unit\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}