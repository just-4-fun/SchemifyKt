{
  "name": "Schemify.Kt",
  "tagline": "Schemification and serialization API for Kotlin",
  "body": "# APIs:\r\n* [**Schemification API**](#schemification-api): Creating a scheme of a class.\r\n* [**Serialization API**](#serialization-api): Transforming an instance of schemified class from/to other format.\r\n\r\n***\r\n\r\n## Schemification API\r\nStructure of a class can be represented as a **Scheme** by mapping class fields to scheme **Props**.  \r\n_In this sense scheme is a special class that represents other class structure as set of Props._  \r\n> \r\n![smf_fieldprop](https://cloud.githubusercontent.com/assets/5307477/17268740/86bae482-563c-11e6-9178-977e9a07e615.png)\r\n\r\nSince the scheme of the class is [defined](#defining-scheme) it can be used for:\r\n* [**serialization**](#scheme-serialization):\r\n    * instance of that class can be read from other formats\r\n    * instance of that class can be written to other formats.\r\n* [**props manipulation**](#prop-manipulation): \r\n    * instance of that class can be assigned with values via props. \r\n    * prop attributes such as name, order index, user defined extras, etc can be used in building requests, DSLs, etc. \r\n* [**extended methods**](#extended-methods) on instance of that class such as equal, copy, toString, hashCode\r\n\r\n### Defining Scheme\r\n- Scheme of `class T` can be defined by extending class [`SCHEMAof<T : Any>`](blob/master/src/main/kotlin/just4fun/kotlin/schemify/core/types.kt#L808). And for each exposing field of `class T` the corresponding prop in the scheme should be created.\r\n> \r\n![smf_define_scheme](https://cloud.githubusercontent.com/assets/5307477/17268824/1d5ed856-563f-11e6-9d4f-adf36bb23e73.png)\r\n\r\n- A prop name and type argument should match the field name and type (no matter nullable or not).\r\n> \r\n![smf_define_props](https://cloud.githubusercontent.com/assets/5307477/17268867/4672d174-5640-11e6-8180-731760e837e1.png)\r\n\r\n- Props can be constructed via methods in scheme class that start from  '**PROP_...**'.  \r\nThe following prop types are supported:  \r\n> \r\n| Type | Constructor | Description |\r\n| --- | --- | --- |\r\n|`Unit`|PROP_STUB()|for _stub_ props|\r\n|Primitive types|PROP_Long() ...|All primitive types: `Long`, `Int`, etc.|\r\n|`String`|PROP_String()|String type|\r\n|Primitive arrays|PROP_Longs() ...|All primitive arrays: `LongArray`, `IntArray`, etc.|\r\n|`MutableMap<String, Any?>`|PROP_Map()|Raw map type|\r\n|`Array<Any?>`|PROP_Array()|Raw array type|\r\n|`Collection<Any?>`|PROP_Collection()|Raw collection type|\r\n|Any|PROP_of(type)|Scheme type //TODO|\r\n|Any|PROP_AutoSchemaOf(type)|AutoSchema type //TODO|\r\n|Any|PROP_of(type)|Value type //TODO|\r\n|Any|PROP_???()|Sequence type //TODO|\r\n     \r\n- Prop has index indicating its declaration position within schema.  \r\nPosition of prop in scheme should NOT match the position of corresponding field in schemified class.\r\n> \r\n![smf_prop_indexes](https://cloud.githubusercontent.com/assets/5307477/17269101/59a43028-5648-11e6-9314-92554abd7ccd.png)\r\n\r\n- Prop should be assigned via delegation and not by ‘=’ sign. That’s because prop should be initialized lazily.\r\n> \r\n![smf_prop_assign_by](https://cloud.githubusercontent.com/assets/5307477/17269119/e8208572-5648-11e6-9683-48053a1946a3.png)\r\n\r\n- By default variable field **`var`** can be modified and final field **`val`** can not be modified via corresponding prop. But default behavior can be altered by setting method argument `writeProtected`.\r\n> \r\n![smf_write_protect](https://cloud.githubusercontent.com/assets/5307477/17269164/7444781e-564a-11e6-9170-2164faabb951.png)\r\n\r\n- Field with access modifier (private etc) is still accessible via corresponding prop.\r\n> \r\n![smf_prop_access](https://cloud.githubusercontent.com/assets/5307477/17269200/047134d6-564b-11e6-8e18-86708d401c18.png)\r\n\r\n- By default prop is configured to use Kotlin reflection instead of Java’s one to access related field. It’s slower (about 2 times) but it’s required in order to invoke field’s custom accessors. But if field doesn’t have custom getter or setter than it may be reasonable to configure prop to use Java reflection by setting method argument `hasNoAccessors` to true.\r\n> \r\n![smf_prop_accessors](https://cloud.githubusercontent.com/assets/5307477/17269236/cedcd720-564b-11e6-83cc-76be5bc857fd.png)\r\n\r\n- If schemified class has main non-empty constructor it should only have class fields (`val` or `var`) as arguments and only those fields that have corresponding props in scheme.  \r\nOrder of fields in constructor doesn’t matter.  \r\nConstructor with access modifier is still accessible by scheme.  \r\nAPI also can not distinguish whether the constructor argument is class field or just local initialization value. So be careful to declare constructor argument with val/var.\r\n> \r\n![smf_constructor](https://cloud.githubusercontent.com/assets/5307477/17269308/7da7c340-564d-11e6-8a19-61addebfc88e.png)\r\n\r\n\r\n### Scheme serialization\r\nAn instance of schemified class can be transformed to / from another format via Serialization API by means of its scheme.  \r\nScheme `read` method can be called to produce new schemified instance from formatted object.   \r\nScheme `write` method can be called to produce formatted object from schemified instance.  \r\n\r\nThe formatted object can be represented in:\r\n* general form (as sequence of named entries)\r\n* compact form (as sequence of non-named entries or which is simply an array of values).  \r\n\r\nDefault representation is controlled by scheme `compact` property. Optional `compact` argument of write method can overwrite that property.  \r\n> \r\n```scala\r\nval sabretooth = XMan()\r\nval generalJson = XSchema.write(sabretooth, JsonFactory) // {“id”:3,“firstname”:”sabretooth”,,,,}\r\nval compactJson = XSchema.write(sabretooth, JsonFactory, compact=true) // [3,”sabretooth”,,,,]\r\nval sabreCopy = XSchema.read(generalJson, JsonFactory)\r\n```\r\n\r\nBenefit of compact form is its compact representation.   \r\n> _Representation example based on Json implementation:_  \r\n![smf_compact_vs_general](https://cloud.githubusercontent.com/assets/5307477/17270002/7669aa86-5660-11e6-928b-2e669bb95452.png)\r\n\r\nOne more advantage of compact form is zero scheme evolution.  \r\nI.e. none of changes to the schemified class (field addition / change / removal) affects transformation of schemified class instance from older schema version to new one and vice versa if props indexes stays intact.   \r\nAs long as prop index corresponds to its declaration position within the schema, props neither should be removed nor their declaration positions should be changed. \r\n\r\n- Changing field name or type:  \r\nIn case of renaming a field its corresponding prop should also be renamed. In case of changing type of a field its corresponding prop’s type should also be changed accordingly. As the representation does not include prop names, changing field name has no effect to transformation. Since API provides basic types casting (// TODO specify which ones), changing field type is compensated by value auto casting in most cases.  \r\n> \r\n![smf_evo_change](https://cloud.githubusercontent.com/assets/5307477/17270017/f693e44c-5660-11e6-8f47-c0eb769e2ba8.png)\r\n\r\n- Field addition:  \r\nIn case of addition a new field the corresponding prop should be just declared after all other props. Adding a field just appends a value to the top a sequence of values. Reading an object written by scheme with older version by scheme with newer version will just assign a default value to the extra field. Reading an object written by newer version of schema with older version will ignore absent value.  \r\n> \r\n![smf_evo_add](https://cloud.githubusercontent.com/assets/5307477/17270018/f8a1e6e4-5660-11e6-9068-f97b178efcd0.png)\r\n\r\n- Field removal:   \r\nIn case of removing a field its corresponding prop should be left and just change its type to Prop<Unit> which is returned by calling PROP_STUB() construction method. Removing a field creates a “hole” in the schema that is just a change of a type of corresponding prop to Prop<Unit>.   \r\n> \r\n![smf_evo_remove](https://cloud.githubusercontent.com/assets/5307477/17270020/fa73fd4a-5660-11e6-8dae-5b07f2e404f5.png)\r\n\r\n\r\n### Prop manipulation\r\n- If a prop doesn’t have the related field in schemified class accessing it will just return null value.  \r\nTo explicitly declare a prop that doesn’t have the related field it should be created via PROP_STUB() method which returns prop of type Prop<Unit>. It’s useful when using compact representation and zero evolution scheme (see next).\r\n\r\n\r\n***\r\n\r\n## Serialization API\r\n**Container** of **entries** represented in one **format** can be transformed to another format.  \r\n> \r\n![ser_examples](https://cloud.githubusercontent.com/assets/5307477/17268380/84b1451a-5631-11e6-95a9-aceacb1fe1ca.png)\r\n\r\n**Container** of type OUT is created by calling _Produce(reader: Reader<IN>, writer: Writer<OUT>)_.\r\nReader<IN> extracts entries from a container of type IN. Those are passed to Writer<OUT> which writes them to the container of type OUT.  \r\nThere are default implementations of Reader and Writer for Json, Xml and Scheme format. For convenience there are also factory singletons for creating their instances.  \r\n_Examples:_\r\n```scala\r\nval orderJson = Produce(SchemeReader(order1, OrderScheme), JsonFactory())\r\nval order2 = Produce(JsonFactory(orderJson), SchemeWriter(OrderScheme))\r\n```\r\n\r\nEntry is a holder of some data. Entry can be named (holding name-value pair) or non-named (holding just value).  \r\nContainer representation should conform the structure:\r\n\r\n![ser_flow](https://cloud.githubusercontent.com/assets/5307477/17268685/76de9650-563a-11e6-91e4-6aeb7ac79034.png)\r\n\r\nSpecific symbols for concrete records, their delimiters and way of encoding named-entry are up to Reader and Writer implementation.  \r\nAtomic value is a data of following base types: String, ByteArray and all the java primitive types.\r\n\r\nTo implement custom Reader class Reader<T : Any> should be extended. And the following methods should be implemented:\r\n```scala\r\ndef readRootEntry(entryBuilder: EntryBuilder): Entry\r\ndef readNextEntry(entryBuilder: EntryBuilder, contextIsSequence: Boolean): Entry\r\n```\r\nTo implement custom Writer class Writer<T : Any> should be extended. And the following methods should be implemented:\r\n```scala\r\ndef result(): T?\r\ndef writeRootEntry(isSequence: Boolean, content: EnclosingEntries): Unit\r\ndef writeObjectEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeSequenceEntry(name: String?, index: Int, content: EnclosingEntries): Unit\r\ndef writeAtomicEntry(value: [all atomic types], name: String?, index: Int): Unit\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}